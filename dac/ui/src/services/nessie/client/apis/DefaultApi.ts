/* tslint:disable */
/* eslint-disable */
/**
 * Nessie API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.18.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import {
    Branch,
    Content,
    DiffResponse,
    EntriesResponse,
    FetchOption,
    GetMultipleContentsRequest,
    GetMultipleContentsResponse,
    LogResponse,
    Merge,
    NessieConfiguration,
    Operations,
    RefLogResponse,
    Reference,
    ReferencesResponse,
    Transplant,
} from '../models';

export interface AssignBranchRequest {
    branchName: string;
    expectedHash?: string;
    reference?: Reference;
}

export interface AssignTagRequest {
    tagName: string;
    expectedHash?: string;
    reference?: Reference;
}

export interface CommitMultipleOperationsRequest {
    branchName: string;
    expectedHash?: string;
    operations?: Operations;
}

export interface CreateReferenceRequest {
    sourceRefName?: string;
    reference?: Reference;
}

export interface DeleteBranchRequest {
    branchName: string;
    expectedHash?: string;
}

export interface DeleteTagRequest {
    tagName: string;
    expectedHash?: string;
}

export interface GetAllReferencesRequest {
    fetch?: FetchOption;
    filter?: string;
    maxRecords?: number;
    pageToken?: string;
}

export interface GetCommitLogRequest {
    ref: string;
    endHash?: string;
    fetch?: FetchOption;
    filter?: string;
    maxRecords?: number;
    pageToken?: string;
    startHash?: string;
}

export interface GetContentRequest {
    key: string;
    hashOnRef?: string;
    ref?: string;
}

export interface GetDiffRequest {
    fromRef: string;
    toRef: string;
}

export interface GetEntriesRequest {
    ref: string;
    filter?: string;
    hashOnRef?: string;
    maxRecords?: number;
    namespaceDepth?: number;
    pageToken?: string;
}

export interface GetMultipleContentsOperationRequest {
    hashOnRef?: string;
    ref?: string;
    getMultipleContentsRequest?: GetMultipleContentsRequest;
}

export interface GetRefLogRequest {
    endHash?: string;
    maxRecords?: number;
    pageToken?: string;
    startHash?: string;
}

export interface GetReferenceByNameRequest {
    ref: string;
    fetch?: FetchOption;
}

export interface MergeRefIntoBranchRequest {
    branchName: string;
    expectedHash?: string;
    merge?: Merge;
}

export interface TransplantCommitsIntoBranchRequest {
    branchName: string;
    expectedHash?: string;
    message?: string;
    transplant?: Transplant;
}

/**
 * 
 */
export class DefaultApi extends runtime.BaseAPI {

    /**
     * This operation takes the name of the branch to reassign and the hash and the name of a named-reference via which the caller has access to that hash.
     * Set a branch to a specific hash via a named-reference.
     */
    async assignBranchRaw(requestParameters: AssignBranchRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.branchName === null || requestParameters.branchName === undefined) {
            throw new runtime.RequiredError('branchName','Required parameter requestParameters.branchName was null or undefined when calling assignBranch.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectedHash !== undefined) {
            queryParameters['expectedHash'] = requestParameters.expectedHash;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/api/v1/trees/branch/{branchName}`.replace(`{${"branchName"}}`, encodeURIComponent(String(requestParameters.branchName))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.reference,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * This operation takes the name of the branch to reassign and the hash and the name of a named-reference via which the caller has access to that hash.
     * Set a branch to a specific hash via a named-reference.
     */
    async assignBranch(requestParameters: AssignBranchRequest, initOverrides?: RequestInit): Promise<void> {
        await this.assignBranchRaw(requestParameters, initOverrides);
    }

    /**
     * This operation takes the name of the tag to reassign and the hash and the name of a named-reference via which the caller has access to that hash.
     * Set a tag to a specific hash via a named-reference.
     */
    async assignTagRaw(requestParameters: AssignTagRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.tagName === null || requestParameters.tagName === undefined) {
            throw new runtime.RequiredError('tagName','Required parameter requestParameters.tagName was null or undefined when calling assignTag.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectedHash !== undefined) {
            queryParameters['expectedHash'] = requestParameters.expectedHash;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/api/v1/trees/tag/{tagName}`.replace(`{${"tagName"}}`, encodeURIComponent(String(requestParameters.tagName))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.reference,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * This operation takes the name of the tag to reassign and the hash and the name of a named-reference via which the caller has access to that hash.
     * Set a tag to a specific hash via a named-reference.
     */
    async assignTag(requestParameters: AssignTagRequest, initOverrides?: RequestInit): Promise<void> {
        await this.assignTagRaw(requestParameters, initOverrides);
    }

    /**
     * Commit multiple operations against the given branch expecting that branch to have the given hash as its latest commit. The hash in the successful response contains the hash of the commit that contains the operations of the invocation.
     */
    async commitMultipleOperationsRaw(requestParameters: CommitMultipleOperationsRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<Branch>> {
        if (requestParameters.branchName === null || requestParameters.branchName === undefined) {
            throw new runtime.RequiredError('branchName','Required parameter requestParameters.branchName was null or undefined when calling commitMultipleOperations.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectedHash !== undefined) {
            queryParameters['expectedHash'] = requestParameters.expectedHash;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/api/v1/trees/branch/{branchName}/commit`.replace(`{${"branchName"}}`, encodeURIComponent(String(requestParameters.branchName))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.operations,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Commit multiple operations against the given branch expecting that branch to have the given hash as its latest commit. The hash in the successful response contains the hash of the commit that contains the operations of the invocation.
     */
    async commitMultipleOperations(requestParameters: CommitMultipleOperationsRequest, initOverrides?: RequestInit): Promise<Branch> {
        const response = await this.commitMultipleOperationsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * The type of \'refObj\', which can be either a \'Branch\' or \'Tag\', determines the type of the reference to be created.  \'Reference.name\' defines the the name of the reference to be created,\'Reference.hash\' is the hash of the created reference, the HEAD of the created reference. \'sourceRefName\' is the name of the reference which contains \'Reference.hash\', and must be present if \'Reference.hash\' is present.  Specifying no \'Reference.hash\' means that the new reference will be created \"at the beginning of time\".
     * Create a new reference
     */
    async createReferenceRaw(requestParameters: CreateReferenceRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<Reference>> {
        const queryParameters: any = {};

        if (requestParameters.sourceRefName !== undefined) {
            queryParameters['sourceRefName'] = requestParameters.sourceRefName;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/api/v1/trees/tree`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.reference,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * The type of \'refObj\', which can be either a \'Branch\' or \'Tag\', determines the type of the reference to be created.  \'Reference.name\' defines the the name of the reference to be created,\'Reference.hash\' is the hash of the created reference, the HEAD of the created reference. \'sourceRefName\' is the name of the reference which contains \'Reference.hash\', and must be present if \'Reference.hash\' is present.  Specifying no \'Reference.hash\' means that the new reference will be created \"at the beginning of time\".
     * Create a new reference
     */
    async createReference(requestParameters: CreateReferenceRequest, initOverrides?: RequestInit): Promise<Reference> {
        const response = await this.createReferenceRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Delete a branch endpoint
     */
    async deleteBranchRaw(requestParameters: DeleteBranchRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.branchName === null || requestParameters.branchName === undefined) {
            throw new runtime.RequiredError('branchName','Required parameter requestParameters.branchName was null or undefined when calling deleteBranch.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectedHash !== undefined) {
            queryParameters['expectedHash'] = requestParameters.expectedHash;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/v1/trees/branch/{branchName}`.replace(`{${"branchName"}}`, encodeURIComponent(String(requestParameters.branchName))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete a branch endpoint
     */
    async deleteBranch(requestParameters: DeleteBranchRequest, initOverrides?: RequestInit): Promise<void> {
        await this.deleteBranchRaw(requestParameters, initOverrides);
    }

    /**
     * Delete a tag
     */
    async deleteTagRaw(requestParameters: DeleteTagRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.tagName === null || requestParameters.tagName === undefined) {
            throw new runtime.RequiredError('tagName','Required parameter requestParameters.tagName was null or undefined when calling deleteTag.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectedHash !== undefined) {
            queryParameters['expectedHash'] = requestParameters.expectedHash;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/v1/trees/tag/{tagName}`.replace(`{${"tagName"}}`, encodeURIComponent(String(requestParameters.tagName))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete a tag
     */
    async deleteTag(requestParameters: DeleteTagRequest, initOverrides?: RequestInit): Promise<void> {
        await this.deleteTagRaw(requestParameters, initOverrides);
    }

    /**
     * Get all references
     */
    async getAllReferencesRaw(requestParameters: GetAllReferencesRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<ReferencesResponse>> {
        const queryParameters: any = {};

        if (requestParameters.fetch !== undefined) {
            queryParameters['fetch'] = requestParameters.fetch;
        }

        if (requestParameters.filter !== undefined) {
            queryParameters['filter'] = requestParameters.filter;
        }

        if (requestParameters.maxRecords !== undefined) {
            queryParameters['maxRecords'] = requestParameters.maxRecords;
        }

        if (requestParameters.pageToken !== undefined) {
            queryParameters['pageToken'] = requestParameters.pageToken;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/v1/trees`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Get all references
     */
    async getAllReferences(requestParameters: GetAllReferencesRequest, initOverrides?: RequestInit): Promise<ReferencesResponse> {
        const response = await this.getAllReferencesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve the commit log for a ref, potentially truncated by the backend.  Retrieves up to \'maxRecords\' commit-log-entries starting at the HEAD of the given named reference (tag or branch) or the given hash. The backend may respect the given \'max\' records hint, but return less or more entries. Backends may also cap the returned entries at a hard-coded limit, the default REST server implementation has such a hard-coded limit.  To implement paging, check \'hasMore\' in the response and, if \'true\', pass the value returned as \'token\' in the next invocation as the \'pageToken\' parameter.  The content and meaning of the returned \'token\' is \"private\" to the implementation,treat is as an opaque value.  It is wrong to assume that invoking this method with a very high \'maxRecords\' value will return all commit log entries.  The \'filter\' parameter allows for advanced filtering capabilities using the Common Expression Language (CEL). An intro to CEL can be found at https://github.com/google/cel-spec/blob/master/doc/intro.md. 
     * Get commit log for a reference
     */
    async getCommitLogRaw(requestParameters: GetCommitLogRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<LogResponse>> {
        if (requestParameters.ref === null || requestParameters.ref === undefined) {
            throw new runtime.RequiredError('ref','Required parameter requestParameters.ref was null or undefined when calling getCommitLog.');
        }

        const queryParameters: any = {};

        if (requestParameters.endHash !== undefined) {
            queryParameters['endHash'] = requestParameters.endHash;
        }

        if (requestParameters.fetch !== undefined) {
            queryParameters['fetch'] = requestParameters.fetch;
        }

        if (requestParameters.filter !== undefined) {
            queryParameters['filter'] = requestParameters.filter;
        }

        if (requestParameters.maxRecords !== undefined) {
            queryParameters['maxRecords'] = requestParameters.maxRecords;
        }

        if (requestParameters.pageToken !== undefined) {
            queryParameters['pageToken'] = requestParameters.pageToken;
        }

        if (requestParameters.startHash !== undefined) {
            queryParameters['startHash'] = requestParameters.startHash;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/v1/trees/tree/{ref}/log`.replace(`{${"ref"}}`, encodeURIComponent(String(requestParameters.ref))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Retrieve the commit log for a ref, potentially truncated by the backend.  Retrieves up to \'maxRecords\' commit-log-entries starting at the HEAD of the given named reference (tag or branch) or the given hash. The backend may respect the given \'max\' records hint, but return less or more entries. Backends may also cap the returned entries at a hard-coded limit, the default REST server implementation has such a hard-coded limit.  To implement paging, check \'hasMore\' in the response and, if \'true\', pass the value returned as \'token\' in the next invocation as the \'pageToken\' parameter.  The content and meaning of the returned \'token\' is \"private\" to the implementation,treat is as an opaque value.  It is wrong to assume that invoking this method with a very high \'maxRecords\' value will return all commit log entries.  The \'filter\' parameter allows for advanced filtering capabilities using the Common Expression Language (CEL). An intro to CEL can be found at https://github.com/google/cel-spec/blob/master/doc/intro.md. 
     * Get commit log for a reference
     */
    async getCommitLog(requestParameters: GetCommitLogRequest, initOverrides?: RequestInit): Promise<LogResponse> {
        const response = await this.getCommitLogRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * List all configuration settings
     */
    async getConfigRaw(initOverrides?: RequestInit): Promise<runtime.ApiResponse<NessieConfiguration>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/v1/config`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * List all configuration settings
     */
    async getConfig(initOverrides?: RequestInit): Promise<NessieConfiguration> {
        const response = await this.getConfigRaw(initOverrides);
        return await response.value();
    }

    /**
     * This operation returns the content-value for a content-key in a named-reference (a branch or tag).  If the table-metadata is tracked globally (Iceberg), Nessie returns a \'Content\' object, that contains the most up-to-date part for the globally tracked part (Iceberg: table-metadata) plus the per-Nessie-reference/hash specific part (Iceberg: snapshot-id, schema-id, partition-spec-id, default-sort-order-id).
     * Get object content associated with a key.
     */
    async getContentRaw(requestParameters: GetContentRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<Content>> {
        if (requestParameters.key === null || requestParameters.key === undefined) {
            throw new runtime.RequiredError('key','Required parameter requestParameters.key was null or undefined when calling getContent.');
        }

        const queryParameters: any = {};

        if (requestParameters.hashOnRef !== undefined) {
            queryParameters['hashOnRef'] = requestParameters.hashOnRef;
        }

        if (requestParameters.ref !== undefined) {
            queryParameters['ref'] = requestParameters.ref;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/v1/contents/{key}`.replace(`{${"key"}}`, encodeURIComponent(String(requestParameters.key))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * This operation returns the content-value for a content-key in a named-reference (a branch or tag).  If the table-metadata is tracked globally (Iceberg), Nessie returns a \'Content\' object, that contains the most up-to-date part for the globally tracked part (Iceberg: table-metadata) plus the per-Nessie-reference/hash specific part (Iceberg: snapshot-id, schema-id, partition-spec-id, default-sort-order-id).
     * Get object content associated with a key.
     */
    async getContent(requestParameters: GetContentRequest, initOverrides?: RequestInit): Promise<Content> {
        const response = await this.getContentRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get default branch for commits and reads
     */
    async getDefaultBranchRaw(initOverrides?: RequestInit): Promise<runtime.ApiResponse<Branch>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/v1/trees/tree`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Get default branch for commits and reads
     */
    async getDefaultBranch(initOverrides?: RequestInit): Promise<Branch> {
        const response = await this.getDefaultBranchRaw(initOverrides);
        return await response.value();
    }

    /**
     * Get a diff for two given references
     */
    async getDiffRaw(requestParameters: GetDiffRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<DiffResponse>> {
        if (requestParameters.fromRef === null || requestParameters.fromRef === undefined) {
            throw new runtime.RequiredError('fromRef','Required parameter requestParameters.fromRef was null or undefined when calling getDiff.');
        }

        if (requestParameters.toRef === null || requestParameters.toRef === undefined) {
            throw new runtime.RequiredError('toRef','Required parameter requestParameters.toRef was null or undefined when calling getDiff.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/v1/diffs/{fromRef}...{toRef}`.replace(`{${"fromRef"}}`, encodeURIComponent(String(requestParameters.fromRef))).replace(`{${"toRef"}}`, encodeURIComponent(String(requestParameters.toRef))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Get a diff for two given references
     */
    async getDiff(requestParameters: GetDiffRequest, initOverrides?: RequestInit): Promise<DiffResponse> {
        const response = await this.getDiffRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieves objects for a ref, potentially truncated by the backend.  Retrieves up to \'maxRecords\' entries for the given named reference (tag or branch) or the given hash. The backend may respect the given \'max\' records hint, but return less or more entries. Backends may also cap the returned entries at a hard-coded limit, the default REST server implementation has such a hard-coded limit.  To implement paging, check \'hasMore\' in the response and, if \'true\', pass the value returned as \'token\' in the next invocation as the \'pageToken\' parameter.  The content and meaning of the returned \'token\' is \"private\" to the implementation,treat is as an opaque value.  It is wrong to assume that invoking this method with a very high \'maxRecords\' value will return all commit log entries.  The \'filter\' parameter allows for advanced filtering capabilities using the Common Expression Language (CEL). An intro to CEL can be found at https://github.com/google/cel-spec/blob/master/doc/intro.md.  The \'namespaceDepth\' parameter returns only the ContentKey components up to the depth of \'namespaceDepth\'. For example they key \'a.b.c.d\' with a depth of 3 will return \'a.b.c\'. The operation is guaranteed to not return  duplicates and therefore will never page.
     * Fetch all entries for a given reference
     */
    async getEntriesRaw(requestParameters: GetEntriesRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<EntriesResponse>> {
        if (requestParameters.ref === null || requestParameters.ref === undefined) {
            throw new runtime.RequiredError('ref','Required parameter requestParameters.ref was null or undefined when calling getEntries.');
        }

        const queryParameters: any = {};

        if (requestParameters.filter !== undefined) {
            queryParameters['filter'] = requestParameters.filter;
        }

        if (requestParameters.hashOnRef !== undefined) {
            queryParameters['hashOnRef'] = requestParameters.hashOnRef;
        }

        if (requestParameters.maxRecords !== undefined) {
            queryParameters['maxRecords'] = requestParameters.maxRecords;
        }

        if (requestParameters.namespaceDepth !== undefined) {
            queryParameters['namespaceDepth'] = requestParameters.namespaceDepth;
        }

        if (requestParameters.pageToken !== undefined) {
            queryParameters['pageToken'] = requestParameters.pageToken;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/v1/trees/tree/{ref}/entries`.replace(`{${"ref"}}`, encodeURIComponent(String(requestParameters.ref))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Retrieves objects for a ref, potentially truncated by the backend.  Retrieves up to \'maxRecords\' entries for the given named reference (tag or branch) or the given hash. The backend may respect the given \'max\' records hint, but return less or more entries. Backends may also cap the returned entries at a hard-coded limit, the default REST server implementation has such a hard-coded limit.  To implement paging, check \'hasMore\' in the response and, if \'true\', pass the value returned as \'token\' in the next invocation as the \'pageToken\' parameter.  The content and meaning of the returned \'token\' is \"private\" to the implementation,treat is as an opaque value.  It is wrong to assume that invoking this method with a very high \'maxRecords\' value will return all commit log entries.  The \'filter\' parameter allows for advanced filtering capabilities using the Common Expression Language (CEL). An intro to CEL can be found at https://github.com/google/cel-spec/blob/master/doc/intro.md.  The \'namespaceDepth\' parameter returns only the ContentKey components up to the depth of \'namespaceDepth\'. For example they key \'a.b.c.d\' with a depth of 3 will return \'a.b.c\'. The operation is guaranteed to not return  duplicates and therefore will never page.
     * Fetch all entries for a given reference
     */
    async getEntries(requestParameters: GetEntriesRequest, initOverrides?: RequestInit): Promise<EntriesResponse> {
        const response = await this.getEntriesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Similar to \'getContent\', but takes multiple \'ContentKey\'s and returns the content-values for the one or more content-keys in a named-reference (a branch or tag).  If the table-metadata is tracked globally (Iceberg), Nessie returns a \'Content\' object, that contains the most up-to-date part for the globally tracked part (Iceberg: table-metadata) plus the per-Nessie-reference/hash specific part (Iceberg: snapshot-ID,schema-ID, partition-spec-ID, default-sort-order-ID).
     * Get multiple objects\' content.
     */
    async getMultipleContentsRaw(requestParameters: GetMultipleContentsOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<GetMultipleContentsResponse>> {
        const queryParameters: any = {};

        if (requestParameters.hashOnRef !== undefined) {
            queryParameters['hashOnRef'] = requestParameters.hashOnRef;
        }

        if (requestParameters.ref !== undefined) {
            queryParameters['ref'] = requestParameters.ref;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/api/v1/contents`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.getMultipleContentsRequest,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Similar to \'getContent\', but takes multiple \'ContentKey\'s and returns the content-values for the one or more content-keys in a named-reference (a branch or tag).  If the table-metadata is tracked globally (Iceberg), Nessie returns a \'Content\' object, that contains the most up-to-date part for the globally tracked part (Iceberg: table-metadata) plus the per-Nessie-reference/hash specific part (Iceberg: snapshot-ID,schema-ID, partition-spec-ID, default-sort-order-ID).
     * Get multiple objects\' content.
     */
    async getMultipleContents(requestParameters: GetMultipleContentsOperationRequest, initOverrides?: RequestInit): Promise<GetMultipleContentsResponse> {
        const response = await this.getMultipleContentsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve the reflog entries from a specified endHash or from the current HEAD if the endHash is null, potentially truncated by the backend.  Retrieves up to \'maxRecords\' refLog-entries starting at the endHash or HEAD.The backend may respect the given \'max\' records hint, but return less or more entries. Backends may also cap the returned entries at a hard-coded limit, the default REST server implementation has such a hard-coded limit.  To implement paging, check \'hasMore\' in the response and, if \'true\', pass the value returned as \'token\' in the next invocation as the \'pageToken\' parameter.  The content and meaning of the returned \'token\' is \"private\" to the implementation,treat is as an opaque value.  It is wrong to assume that invoking this method with a very high \'maxRecords\' value will return all reflog entries.  
     * Get reflog entries
     */
    async getRefLogRaw(requestParameters: GetRefLogRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<RefLogResponse>> {
        const queryParameters: any = {};

        if (requestParameters.endHash !== undefined) {
            queryParameters['endHash'] = requestParameters.endHash;
        }

        if (requestParameters.maxRecords !== undefined) {
            queryParameters['maxRecords'] = requestParameters.maxRecords;
        }

        if (requestParameters.pageToken !== undefined) {
            queryParameters['pageToken'] = requestParameters.pageToken;
        }

        if (requestParameters.startHash !== undefined) {
            queryParameters['startHash'] = requestParameters.startHash;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/v1/reflogs`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Retrieve the reflog entries from a specified endHash or from the current HEAD if the endHash is null, potentially truncated by the backend.  Retrieves up to \'maxRecords\' refLog-entries starting at the endHash or HEAD.The backend may respect the given \'max\' records hint, but return less or more entries. Backends may also cap the returned entries at a hard-coded limit, the default REST server implementation has such a hard-coded limit.  To implement paging, check \'hasMore\' in the response and, if \'true\', pass the value returned as \'token\' in the next invocation as the \'pageToken\' parameter.  The content and meaning of the returned \'token\' is \"private\" to the implementation,treat is as an opaque value.  It is wrong to assume that invoking this method with a very high \'maxRecords\' value will return all reflog entries.  
     * Get reflog entries
     */
    async getRefLog(requestParameters: GetRefLogRequest, initOverrides?: RequestInit): Promise<RefLogResponse> {
        const response = await this.getRefLogRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Fetch details of a reference
     */
    async getReferenceByNameRaw(requestParameters: GetReferenceByNameRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<Reference>> {
        if (requestParameters.ref === null || requestParameters.ref === undefined) {
            throw new runtime.RequiredError('ref','Required parameter requestParameters.ref was null or undefined when calling getReferenceByName.');
        }

        const queryParameters: any = {};

        if (requestParameters.fetch !== undefined) {
            queryParameters['fetch'] = requestParameters.fetch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/v1/trees/tree/{ref}`.replace(`{${"ref"}}`, encodeURIComponent(String(requestParameters.ref))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Fetch details of a reference
     */
    async getReferenceByName(requestParameters: GetReferenceByNameRequest, initOverrides?: RequestInit): Promise<Reference> {
        const response = await this.getReferenceByNameRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Merge items from an existing hash in \'mergeRef\' into the requested branch. The merge is always a rebase + fast-forward merge and is only completed if the rebase is conflict free. The set of commits added to the branch will be all of those until we arrive at a common ancestor. Depending on the underlying implementation, the number of commits allowed as part of this operation may be limited.
     * Merge commits from \'mergeRef\' onto \'branchName\'.
     */
    async mergeRefIntoBranchRaw(requestParameters: MergeRefIntoBranchRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.branchName === null || requestParameters.branchName === undefined) {
            throw new runtime.RequiredError('branchName','Required parameter requestParameters.branchName was null or undefined when calling mergeRefIntoBranch.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectedHash !== undefined) {
            queryParameters['expectedHash'] = requestParameters.expectedHash;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/api/v1/trees/branch/{branchName}/merge`.replace(`{${"branchName"}}`, encodeURIComponent(String(requestParameters.branchName))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.merge,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Merge items from an existing hash in \'mergeRef\' into the requested branch. The merge is always a rebase + fast-forward merge and is only completed if the rebase is conflict free. The set of commits added to the branch will be all of those until we arrive at a common ancestor. Depending on the underlying implementation, the number of commits allowed as part of this operation may be limited.
     * Merge commits from \'mergeRef\' onto \'branchName\'.
     */
    async mergeRefIntoBranch(requestParameters: MergeRefIntoBranchRequest, initOverrides?: RequestInit): Promise<void> {
        await this.mergeRefIntoBranchRaw(requestParameters, initOverrides);
    }

    /**
     * This is done as an atomic operation such that only the last of the sequence is ever visible to concurrent readers/writers. The sequence to transplant must be contiguous and in order.
     * Transplant commits from \'transplant\' onto \'branchName\'
     */
    async transplantCommitsIntoBranchRaw(requestParameters: TransplantCommitsIntoBranchRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.branchName === null || requestParameters.branchName === undefined) {
            throw new runtime.RequiredError('branchName','Required parameter requestParameters.branchName was null or undefined when calling transplantCommitsIntoBranch.');
        }

        const queryParameters: any = {};

        if (requestParameters.expectedHash !== undefined) {
            queryParameters['expectedHash'] = requestParameters.expectedHash;
        }

        if (requestParameters.message !== undefined) {
            queryParameters['message'] = requestParameters.message;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/api/v1/trees/branch/{branchName}/transplant`.replace(`{${"branchName"}}`, encodeURIComponent(String(requestParameters.branchName))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.transplant,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * This is done as an atomic operation such that only the last of the sequence is ever visible to concurrent readers/writers. The sequence to transplant must be contiguous and in order.
     * Transplant commits from \'transplant\' onto \'branchName\'
     */
    async transplantCommitsIntoBranch(requestParameters: TransplantCommitsIntoBranchRequest, initOverrides?: RequestInit): Promise<void> {
        await this.transplantCommitsIntoBranchRaw(requestParameters, initOverrides);
    }

}
